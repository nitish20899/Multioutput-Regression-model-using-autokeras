# -*- coding: utf-8 -*-
"""autokeras.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jjCDhQjya4W1gGjS_3P88E-M-Hgk7bg-
"""

from google.colab import drive

drive.mount('/content/gdrive')

!pip install autokeras

from numpy import mean
from numpy import std
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
import imageio as imread
import os
from PIL import Image
from tensorflow.python.keras.callbacks import EarlyStopping, ModelCheckpoint
import tensorflow
import autokeras as ak
from sklearn.model_selection import train_test_split

def load_images(path):
    images = []
    for filename in os.listdir(path):
        img = Image.open(path + filename)
        img_resize = img.resize((256, 256)) 
        img = img_resize.convert("L") # GREY CHANNEL ( SINGLE CHANNEL )
        img_array = np.array(img)
#       img_array = img_array.reshape((1, img_array.shape[0], img_array.shape[1], img_array.shape[2]))
        images.append(img_array)

    images1 = np.array(images)
    return images1,images

y_df = pd.read_csv('/content/gdrive/MyDrive/BishopThesis/AnimationTransform.csv')
y_df

y_df[y_df['JointName']=='mixamorig:LeftForeArm'][:209][['position.x','position.y','position.z','rotation.x','rotation.y','rotation.z']]

# Function to create dataset for 18 classes 
def create_data(path_images, path_csv, class_needed):
  All_images , list_images= load_images(path_images)
  y_df = pd.read_csv(path_csv)
  Y= y_df[y_df['JointName']==class_needed][:209][['position.x','position.y','position.z','rotation.x','rotation.y','rotation.z']]
  y = np.array(Y)
  return All_images,y

# scaler = MinMaxScaler(feature_range=(0, 1))
# y = scaler.fit_transform(y)
# creating dataet
All_images,y = create_data('/content/gdrive/MyDrive/BishopThesis/CameraFrame/','/content/gdrive/MyDrive/BishopThesis/AnimationTransform.csv','mixamorig:LeftForeArm')

x_train, x_test, y_train, y_test = train_test_split( All_images, y, test_size=0.20, random_state=12)

# Reshape the images to have the channel dimension for RESNET.
x_train = x_train.reshape(x_train.shape + (1,))
x_test = x_test.reshape(x_test.shape + (1,))

print(x_train.shape)  # (60000, 28, 28)
print(y_train.shape)  # (60000,)
print(y_train[:3])

callback = EarlyStopping(monitor='loss', patience=5)

input_node = ak.ImageInput()
output_node = ak.ImageBlock(
    # Only search ResNet architectures.
    block_type="xception",
    # Normalize the dataset.,
    normalize='False',
    # Do not do data augmentation.
    augment=False,
)(input_node)
output_node = ak.RegressionHead()(output_node)
# Feed the image regressor with training data.
reg = ak.AutoModel(
    inputs=input_node, outputs=output_node, overwrite=True, max_trials=1 # hyper parmater tuning 
)
reg.fit(x_train, y_train, callbacks = [callback],validation_data=(x_test, y_test),epochs=100)
classname = 'mixamorig:LeftForeArm'

model = reg.export_model()

print(type(model))  # <class 'tensorflow.python.keras.engine.training.Model'>
modelname = '/content/gdrive/MyDrive/BishopThesis/models_trained/'+classname+'_model'
modelname_save = '/content/gdrive/MyDrive/BishopThesis/models_trained/'+modelname+'.h5'
try:
    model.save(modelname, save_format="tf")
except Exception:
    model.save(modelname_save)

# Predict with the best model for LeftForeArm positions and rotations.
predicted_y = reg.predict(x_test)
print(predicted_y)

# Evaluate the best model with testing data.
print(reg.evaluate(x_test, y_test))

"""**Currently we only predicted positionxyz and rotationxyz for LeftForeArm. We need to predict for other 17 features and save all the best models for all the classes**"""

import tensorflow as tf
def load_images(path):
    images = []
    for filename in os.listdir(path):
        img = Image.open(path + filename)
        img_resize = img.resize((256, 256)) 
        img = img_resize.convert("L")
        img_array = np.array(img)
#       img_array = img_array.reshape((1, img_array.shape[0], img_array.shape[1], img_array.shape[2]))
        images.append(img_array)

    images1 = np.array(images)
    return images1,images

    
def create_data(path_images, path_csv, class_needed):
  All_images , list_images= load_images(path_images)
  y_df = pd.read_csv(path_csv)
  Y= y_df[y_df['JointName']==class_needed][:209][['position.x','position.y','position.z','rotation.x','rotation.y','rotation.z']]
  y = np.array(Y)
  return All_images,y



def Final_model(classname): 
  All_images,y = create_data('/content/gdrive/MyDrive/freelancing/Razieh/CameraFrame/','/content/gdrive/MyDrive/freelancing/Razieh/AnimationTransform.csv',classname)

  def scheduler(epoch, lr):
    if epoch < 10:
      return lr
    else:
      return lr * tf.math.exp(-0.1)

  x_train, x_test, y_train, y_test = train_test_split( All_images, y, test_size=0.20, random_state=12)
  x_train = x_train.reshape(x_train.shape + (1,))
  x_test = x_test.reshape(x_test.shape + (1,))

  callback = EarlyStopping(monitor='loss', patience=5)
  lr_scheduler = tf.keras.callbacks.LearningRateScheduler( scheduler)
  input_node = ak.ImageInput()
  output_node = ak.ImageBlock(
      # Only search ResNet architectures.
      block_type="xception",
      # Normalize the dataset.,
      normalize='False',
      # Do not do data augmentation.
      augment=False,
  )(input_node)
  output_node = ak.RegressionHead()(output_node)
  # Feed the image regressor with training data.
  reg = ak.AutoModel(
      inputs=input_node, outputs=output_node, overwrite=True, max_trials=1
  )
  reg.fit(x_train, y_train, callbacks = [callback,lr_scheduler],validation_data=(x_test, y_test),epochs=100)
  predicted_y = reg.predict(x_test)
  filename = 'predicted_LeftForeArm.csv'
  model = reg.export_model()

  print(type(model))  # <class 'tensorflow.python.keras.engine.training.Model'>
  modelname = '/content/gdrive/MyDrive/freelancing/Razieh/models_trained/'+classname+'_model'
  modelname_save = '/content/gdrive/MyDrive/freelancing/Razieh/models_trained/'+modelname+'.h5'
  try:
      model.save(modelname, save_format="tf")
  except Exception:
      model.save(modelname_save)

  return predicted_y,x_test

predicted_LeftForeArm,x_test_LeftForeArm = Final_model('mixamorig:LeftForeArm')
predicted_LeftFoot,x_test_LeftFoot = Final_model('mixamorig:LeftFoot')
predicted_LeftHandMiddle1,x_test_LeftHandMiddle1 = Final_model('mixamorig:LeftHandMiddle1')
predicted_RightForeArm,x_test_RightForeArm = Final_model('mixamorig:RightForeArm')
predicted_RightShoulder,x_test_RightShoulder = Final_model('mixamorig:RightShoulder')
predicted_RightUpLeg,x_test_RightUpLeg = Final_model('mixamorig:RightUpLeg')
predicted_Hips,x_test_Hips = Final_model('mixamorig:Hips')
predicted_LeftLeg,x_test_LeftLeg = Final_model('mixamorig:LeftLeg')
predicted_RightHand,x_test_RightHand = Final_model('mixamorig:RightHand')
predicted_Neck,x_test_Neck = Final_model('mixamorig:Neck')
predicted_RightLeg,x_test_RightLeg = Final_model('mixamorig:RightLeg')
predicted_LeftUpLeg,x_test_LeftUpLeg = Final_model('mixamorig:LeftUpLeg')
predicted_LeftShoulder,x_test_LeftShoulder = Final_model('mixamorig:LeftShoulder')
predicted_LeftHand,x_test_LeftHand = Final_model('mixamorig:LeftHand')
predicted_RightArm,x_test_RightArm = Final_model('mixamorig:RightArm')
predicted_Spine,x_test_Spine = Final_model('mixamorig:Spine')
predicted_RightFoot,x_test_RightFoot = Final_model('mixamorig:RightFoot')
predicted_Head,x_test_Head = Final_model('mixamorig:Head')

# Load the saved model and get the predictions
from keras.models import load_model
loaded_model = load_model("model_autokeras/content/gdrive/MyDrive/BishopThesis/models_trained/mixamorig:LeftForeArm_model", custom_objects=ak.CUSTOM_OBJECTS)
predicted_y = loaded_model.predict(tf.expand_dims(x_test, -1))
print(predicted_y)

"""**The model is giving average results even with advanced deep learning networks because:**
*   Dataset is small and even with augumentation its is difficult to get appropiate data ( Need more data )
*   The dataset has more surroundings than the actual object so cropping the image which contains only the human will increase the model performance
*   This is a regression problem and performing multiregression model using VGG16 ,Inception..etc wont have better performance as they are mostly designed for classification
*   To solve the above problem a seperate model for each class-->for 2 Positions or rotations should be done 

**Currently, I developed a single model which takes 18 different classes and gives all 6 classes as output but due to the upper limiting constraints the accuracy is not good. Once the above issues are solved , It can be done easily using the current code as reference**

NOTE: Another easy way is to create a regression machine learning models like Decision Tree, Random Forest..etc
"""

# Below is the code for predicting only 2 labels for each class so that you can get accurate results.
import tensorflow as tf
def load_images(path):
    images = []
    for filename in os.listdir(path):
        img = Image.open(path + filename)
        img_resize = img.resize((256, 256)) 
        img = img_resize.convert("L")
        img_array = np.array(img)
#       img_array = img_array.reshape((1, img_array.shape[0], img_array.shape[1], img_array.shape[2]))
        images.append(img_array)

    images1 = np.array(images)
    return images1,images

    
def create_data(path_images, path_csv, class_needed,labels1,labels2):
  All_images , list_images= load_images(path_images)
  y_df = pd.read_csv(path_csv)
  Y= y_df[y_df['JointName']==class_needed][:209][[labels1,labels2]]
  y = np.array(Y)
  return All_images,y



def Final_model(classname,labels1,labels2): 
  All_images,y = create_data('/content/gdrive/MyDrive/BishopThesis/CameraFrame/','/content/gdrive/MyDrive/BishopThesis/AnimationTransform.csv',classname,labels1,labels2)
  def scheduler(epoch, lr):
    if epoch < 10:
      return lr
    else:
      return lr * tf.math.exp(-0.1)

  x_train, x_test, y_train, y_test = train_test_split( All_images, y, test_size=0.20, random_state=12)
  x_train = x_train.reshape(x_train.shape + (1,))
  x_test = x_test.reshape(x_test.shape + (1,))

  callback = EarlyStopping(monitor='loss', patience=5)
  lr_scheduler = tf.keras.callbacks.LearningRateScheduler(scheduler)
  input_node = ak.ImageInput()
  output_node = ak.ImageBlock(
      # Only search ResNet architectures.
      block_type="xception",
      # Normalize the dataset.,
      normalize='False',
      # Do not do data augmentation.
      augment=False,
  )(input_node)
  output_node = ak.RegressionHead()(output_node)
  # Feed the image regressor with training data.
  reg = ak.AutoModel(
      inputs=input_node, outputs=output_node, overwrite=True, max_trials=1
  )
  reg.fit(x_train, y_train, callbacks = [callback,lr_scheduler],validation_data=(x_test, y_test),epochs=100)
  predicted_y = reg.predict(x_test)
  filename = 'predicted_LeftForeArm.csv'
  model = reg.export_model()

  print(type(model))  # <class 'tensorflow.python.keras.engine.training.Model'>
  modelname = '/content/gdrive/MyDrive/freelancing/Razieh/models_trained/'+classname+labels1+labels2+'_model'
  modelname_save = '/content/gdrive/MyDrive/freelancing/Razieh/models_trained/'+modelname+labels1+labels2+'.h5'
  try:
      model.save(modelname, save_format="tf")
  except Exception:
      model.save(modelname_save)

  return predicted_y,x_test

predicted_LeftForeArm,x_test_LeftForeArm = Final_model('mixamorig:LeftForeArm','position.x','position.y')
predicted_LeftFoot,x_test_LeftFoot = Final_model('mixamorig:LeftFoot','position.x','position.y')
predicted_LeftHandMiddle1,x_test_LeftHandMiddle1 = Final_model('mixamorig:LeftHandMiddle1','position.x','position.y')
predicted_RightForeArm,x_test_RightForeArm = Final_model('mixamorig:RightForeArm','position.x','position.y')
predicted_RightShoulder,x_test_RightShoulder = Final_model('mixamorig:RightShoulder','position.x','position.y')
predicted_RightUpLeg,x_test_RightUpLeg = Final_model('mixamorig:RightUpLeg','position.x','position.y')
predicted_Hips,x_test_Hips = Final_model('mixamorig:Hips','position.x','position.y')
predicted_LeftLeg,x_test_LeftLeg = Final_model('mixamorig:LeftLeg','position.x','position.y')
predicted_RightHand,x_test_RightHand = Final_model('mixamorig:RightHand','position.x','position.y')
predicted_Neck,x_test_Neck = Final_model('mixamorig:Neck','position.x','position.y')
predicted_RightLeg,x_test_RightLeg = Final_model('mixamorig:RightLeg','position.x','position.y')
predicted_LeftUpLeg,x_test_LeftUpLeg = Final_model('mixamorig:LeftUpLeg','position.x','position.y')
predicted_LeftShoulder,x_test_LeftShoulder = Final_model('mixamorig:LeftShoulder','position.x','position.y')
predicted_LeftHand,x_test_LeftHand = Final_model('mixamorig:LeftHand','position.x','position.y')
predicted_RightArm,x_test_RightArm = Final_model('mixamorig:RightArm','position.x','position.y')
predicted_Spine,x_test_Spine = Final_model('mixamorig:Spine','position.x','position.y')
predicted_RightFoot,x_test_RightFoot = Final_model('mixamorig:RightFoot','position.x','position.y')
predicted_Head,x_test_Head = Final_model('mixamorig:Head','position.x','position.y')




predicted_LeftForeArm,x_test_LeftForeArm = Final_model('mixamorig:LeftForeArm','position.z','rotation.x')
predicted_LeftFoot,x_test_LeftFoot = Final_model('mixamorig:LeftFoot','position.z','rotation.x')
predicted_LeftHandMiddle1,x_test_LeftHandMiddle1 = Final_model('mixamorig:LeftHandMiddle1','position.z','rotation.x')
predicted_RightForeArm,x_test_RightForeArm = Final_model('mixamorig:RightForeArm','position.z','rotation.x')
predicted_RightShoulder,x_test_RightShoulder = Final_model('mixamorig:RightShoulder','position.z','rotation.x')
predicted_RightUpLeg,x_test_RightUpLeg = Final_model('mixamorig:RightUpLeg','position.z','rotation.x')
predicted_Hips,x_test_Hips = Final_model('mixamorig:Hips','position.z','rotation.x')
predicted_LeftLeg,x_test_LeftLeg = Final_model('mixamorig:LeftLeg','position.z','rotation.x')
predicted_RightHand,x_test_RightHand = Final_model('mixamorig:RightHand','position.z','rotation.x')
predicted_Neck,x_test_Neck = Final_model('mixamorig:Neck','position.z','rotation.x')
predicted_RightLeg,x_test_RightLeg = Final_model('mixamorig:RightLeg','position.z','rotation.x')
predicted_LeftUpLeg,x_test_LeftUpLeg = Final_model('mixamorig:LeftUpLeg','position.z','rotation.x')
predicted_LeftShoulder,x_test_LeftShoulder = Final_model('mixamorig:LeftShoulder','position.z','rotation.x')
predicted_LeftHand,x_test_LeftHand = Final_model('mixamorig:LeftHand','position.z','rotation.x')
predicted_RightArm,x_test_RightArm = Final_model('mixamorig:RightArm','position.z','rotation.x')
predicted_Spine,x_test_Spine = Final_model('mixamorig:Spine','position.z','rotation.x')
predicted_RightFoot,x_test_RightFoot = Final_model('mixamorig:RightFoot','position.z','rotation.x')
predicted_Head,x_test_Head = Final_model('mixamorig:Head','position.z','rotation.x')



predicted_LeftForeArm,x_test_LeftForeArm = Final_model('mixamorig:LeftForeArm','rotation.y','rotation.z')
predicted_LeftFoot,x_test_LeftFoot = Final_model('mixamorig:LeftFoot','rotation.y','rotation.z')
predicted_LeftHandMiddle1,x_test_LeftHandMiddle1 = Final_model('mixamorig:LeftHandMiddle1','rotation.y','rotation.z')
predicted_RightForeArm,x_test_RightForeArm = Final_model('mixamorig:RightForeArm','rotation.y','rotation.z')
predicted_RightShoulder,x_test_RightShoulder = Final_model('mixamorig:RightShoulder','rotation.y','rotation.z')
predicted_RightUpLeg,x_test_RightUpLeg = Final_model('mixamorig:RightUpLeg','rotation.y','rotation.z')
predicted_Hips,x_test_Hips = Final_model('mixamorig:Hips','rotation.y','rotation.z')
predicted_LeftLeg,x_test_LeftLeg = Final_model('mixamorig:LeftLeg','rotation.y','rotation.z')
predicted_RightHand,x_test_RightHand = Final_model('mixamorig:RightHand','rotation.y','rotation.z')
predicted_Neck,x_test_Neck = Final_model('mixamorig:Neck','rotation.y','rotation.z')
predicted_RightLeg,x_test_RightLeg = Final_model('mixamorig:RightLeg','rotation.y','rotation.z')
predicted_LeftUpLeg,x_test_LeftUpLeg = Final_model('mixamorig:LeftUpLeg','rotation.y','rotation.z')
predicted_LeftShoulder,x_test_LeftShoulder = Final_model('mixamorig:LeftShoulder','rotation.y','rotation.z')
predicted_LeftHand,x_test_LeftHand = Final_model('mixamorig:LeftHand','rotation.y','rotation.z')
predicted_RightArm,x_test_RightArm = Final_model('mixamorig:RightArm','rotation.y','rotation.z')
predicted_Spine,x_test_Spine = Final_model('mixamorig:Spine','rotation.y','rotation.z')
predicted_RightFoot,x_test_RightFoot = Final_model('mixamorig:RightFoot','rotation.y','rotation.z')
predicted_Head,x_test_Head = Final_model('mixamorig:Head','rotation.y','rotation.z')

